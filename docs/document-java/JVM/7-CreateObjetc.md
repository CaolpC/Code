# 对象实例化内存布局喝访问定位

## 对象实例化

### 对象创建的方式

    1. new、Xxx的静态方法、XxxBuilder/XxxFactory
    2. Class 的 newInstance() 反射的方式，空参构造器，权限必须是 public
    3. Constructor 的 NewInstance() 反射的方式，调用空参方式、带参构造器，权限没有要求
    4. clone() 不调用任何构造器，当前类需要实现 Cloneable 接口
    5. 使用反序列化 从文件、网络获取对象的二进制流，还原对象
    6. 使用 Objenesis

### 创建对象的步骤

    1. 判断对象对应的类是否加载、链接、初始化
    2. 为对象分配内存:
       1. 内存规整：指针碰撞
       2. 不规整：维护一个列表，空闲列表分配，取决于垃圾搜集器
    3. 处理并发安全问题
       1. CAS 失败重试，区域加锁保证更新的原子性
       2. 每个线程预留分配一块 TLAB
    4. 初始化分配到的空间，对象的每一个属性都进行默认初始化
    5. 设置对象的对象头
    6. 执行 init 方法的初始化，显示初始化，代码块初始化，构造器初始化

## 内存布局

    1. 对象头
       1. 运行时元数据
          1. 哈希值（引用的首地址）
          2. GC 分代年龄
          3. 锁状态标志
          4. 线程持有的锁
          5. 偏向线程 ID
          6. 偏向时间戳
       2. 类型指针
          1. 指向类元数据 InstanceKlass, 确定该对象所属的类型
       3. 如果是数组，还需要记录数组长度
    2. 实例数据
       1. 对象存储的真正有效信息，各种类型的字段，包括父类继承下来的字段
       2. 规则：
          1. 父类定义的出现在子类之前
          2. 相同宽度的被分配在一起
          3. ComPactFields 参数为 true: 子类可以插入到父类变量的空隙
    3. 对齐填充，占位符

![20210705215634](https://cdn.jsdelivr.net/gh/RamboCao/PicGo/images/20210705215634.png)

## 访问定位

      通过栈帧中的对象引用访问内部的对象实例

      1. 句柄访问
         1. 句柄池，开辟空间，效率较低
         2. 堆空间对象发生移动，只需要修改句柄池指针

      2. 直接指针
         1. 效率较高，没有句柄池

***HotSpot 采用的是第二种方式***

![句柄访问](https://cdn.jsdelivr.net/gh/RamboCao/PicGo/images/20210705221148.png)

![直接指针](https://cdn.jsdelivr.net/gh/RamboCao/PicGo/images/20210705221303.png)