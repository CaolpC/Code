# 方法区

## 栈、堆、方法区的交互

    内存区域：
        线程共享：堆和元空间，OOM: Java heap space + OOM: Metaspace/perm
        线程私有：虚拟机栈 + 本地方法栈：StackOverFlowError + 程序计数器

```java
Person person = new Person()

// 方法区 + Java栈 + Java 堆
```

## 方法区的理解

    方法区：独立于 Java 堆的内存空间， 非堆

    各个线程共享的区域，相同类只需要加载一次

    JVM 启动时创建，可以不连续

    可以固定大小，也可以扩展

    决定系统可以保存多少类，系统定义太多类，导致方法区溢出 OOM: permGen space / OOM: meta space，加载大量的第三方 jar
    包，大量动态生成反射类

    关闭 JVM，释放方法区内存

### 方法区的演进

    Hotspot 虚拟机

    jdk7 以及以前，永久代, jdk8 元空间取代永久代

    使用的是本地内存

    方法区与永久代不等价！仅仅是对 hotspot 中是这样

    JRockit 和 J9 不存在永久代概念

    永久代仍然使用的是 JVM 内存，更容易 OOM

    元空间不在虚拟机设置的内存中，使用的是本地内存

    二者之间内部结构也调整了

    方法区无法满足新的内存分配需求，抛出 OOM 异常

## 设置方法区与 OOM

    固定大小或者自动增长

    永久代：
        -XX:permSize 初始化 20.75M
        -XX:MaxPermSize 最大可分配空间， 32 位机器 64M, 64 位机器 82M
        超过 OOM: PermGen Space

    元空间：
        -XX:MetaspaceSize 初始化 win 约等于21
        -XX:MaxMetaspaceSize 值为 -1，没有限制

    超过 21M，就会 Full GC 触发并且写在没用的类，高水平设置过低，Full GC 就会多次调用，频繁发生 GC, 建议一次性设置的稍微大一点

### 如何解决 OOM

    快照，分析是内存溢出还是内存泄漏

    内存泄漏，对象不使用，但是还有关联

    内存溢出，检查虚拟机堆参数，静态，局部变量

## 方法区内部结构

    存储已经被虚拟机加载的 类型信息、常量、静态变量、即使编译器编译后的代码缓存等

    类型信息，域信息、方法信息

    类的加载器，与 class 文件互相记录

### 类型信息

    全类名、父类完整有效名、修饰符、类的实现接口的一个有序列表

    域信息：域名称、域类型、域修饰符（public, private, protected, static, final, volatile, transient）

    方法信息: 方法名称，方法返回类型，参数数量，方法修饰符，方法字节码、操作数栈、局部变量表及大小（abstract 和 native 方法除外），异常表

    non-final: 静态变量与类关联，随类的加载而加载，类变量被类的所有实例共享，即使类不实例化也能访问

    static final 声明的变量，在编译期间就被初始化

### 运行时常量池

    运行时常量池与常量池

    常量池包含了各种字面量和对类型域和方法的引用

    为什么用常量池：加载大量的信息，节约空间，进行复用

    常量池可以看作一张表，虚拟机指令根据这张表找到执行的类名、方法名、参数类型、字面量等类型

    运行时常量池：方法区一部分，字节码中的常量池通过类加载器加载到方法区之后就变成了运行时常量池

    运行时常量池相比于常量池的重要特征是：具备动态性，String.intern() 常量池没有，会放一个进去

## 方法区使用举例

## 方法区演进

    HotSpot 才有永久代

    jdk1.6 存在永久代 + 静态变量存放在永久代

    jdk1.7 有永久代，字符串常量池、静态变量移除，保存在堆中

    jdk1.8 无永久代， 类型信息、字段、方法、常量保存在本地内存的元空间，字符串常量池、静态变量仍然在堆

***永久代为什么被元空间替换： JRcoket 和 HotSpot 融合的结果***

    1. 永久代设置控件大小很难确定，元空间使用的是本地内存
    2. 永久代调优很难

***StringTable为什么调整位置***

    永久代的回收频率较低，full gc 才会触发，老年代空间不足，永久代不足
    
    StringTable 回收效率不高，大量字符串被创建，永久代内存不足

***静态/成员变量变量放在哪***

    jdk7 放在老年代
    jdk8 放在老年代

    静态引用对应的对象实体始终都在堆里边

    引用名字发生了变化， jdk6 在永久代，7，8在堆空间中

    new 的对象都在堆空间中

## 方法区垃圾回收

    回收条件：
    所有实例都被回收，不存在该类以及其任何派生子类实例都已经被回收
    类的加载器被回收
    Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 总结
