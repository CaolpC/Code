# 垃圾回收器

## 垃圾回收概述

### 什么是垃圾

    哪些内存需要回收
    什么时候回收
    如何回收

    垃圾：程序运行中没有任何指针指向的对象
    不及时清理，垃圾会逐渐填满，空间满，然后内存溢出或者内存泄漏

    内存迟早会被消耗完，JVM 整理出的内存分配给新的对象

    GC 保证应用程序的正常执行

### 早期垃圾回收

    手动进行
    频繁申请和释放内存的管理负担，忘记被回收，内存泄漏，直到应用程序崩溃

    自动分配和垃圾自动回收

    自动内存管理，降低内存泄漏和溢出的风险

    依赖，监控和调节

    主要作用于方法区和堆区

    堆区是重点工作区域，频繁 Young, 较少 Old，基本不懂元空间

## 垃圾回收相关算法

### 标记阶段：引用计数算法

    垃圾标记阶段: 判断对象存活状态

    一个对象不被任何存活对象引用时，就为死亡状态

    判断存活两种方式：引用计数算法和可达性分析算法

    每一个对象保存一个整型的引用计数器属性，记录对象被引用的情况 +1，-1

    优点：实现简单、垃圾对象便于标识，判断效率高，回收无延迟
    缺点：
        1. 存储空间开销、时间开销
        2. 无法处理循环引用（内存泄漏问题）
    
    面试：内存泄漏最好不选择引用计数器作为举例，因为 Java 中没有使用引用计数算法

    Python 使用了引用计数算法，手动解除；使用弱引用 weakref, 弱引用都会回收，解决循环引用

### 标记阶段：可达性分析算法

    根搜索算法、追踪性垃圾搜集

    简单，高效，解决循环引用。防止内存泄漏

    GC Root 根集合就是一组活跃的引用

    从上到下搜索被根对象所连接的目标对象是否可达，存活对象被直接或者间接相连

    不可达就是垃圾

    GC Roots:
        1. 虚拟机栈中引用的对象，局部变量表中
        2. 本地方法栈中引用对象
        3. 方法区中类静态属性引用的对象
        4. 方法区中常量引用的对象
        5. 所有被同步锁 synchronized 持有的对象
        6. Java 虚拟机的内部的引用：基本数据类型对应的 Class 对象，常驻的异常对象，系统类加载器
        7. 反应 java 虚拟机内部情况的 JMXBean，JVMTI 中注册的回调，本地代码缓存

    判断 GC Roots 的小技巧：如果一个指针保存了堆内存里边的对象，自己又不存在堆内存里边，就是一个 Root

    可能会临时加入一些 GC Root, 例如分代搜集和局部回收
        如果只考虑新生代，那么堆的其它部分就可以加入到 GC Roots 中
    
    分析工作必须保证在一个保证一致性的快照中进行，保证分析结果的准确性

    一致性：必须 STW，枚举根节点必须进行停顿

### 对象的 finalization 机制

    对象回收之前，被销毁之前的自定义处理逻辑

    垃圾回收器发现没有一个引用指向对象，在垃圾回收之前会调用该方法的 finalize 方法

    finalize() 方法在 Object 中

    finalize() 方法可以被重写，对象回收时进行资源释放，关闭文件、套接字和数据库连接

    注意：永远不要主动调用对象的 finalize() 方法
        1. 导致对象复活
        2. 执行时间没有保证，由 GC 线程决定，极端情况下没有 GC，该方法将没有执行机会
        3. 严重的影响 GC 的性能（死循环）

#### 对象的几种状态

    finalize() 方法的存在，导致对象有三种状态：

    根节点无法访问，也并非一定会被回收

    1. 可触及的，不是垃圾

    2. 可复活的，对象的所有引用被释放，可能在 finalize() 复活

    3. 不可触及的，对象的 finalize() 被调用，没有复活，会进入到不可触及状态, 不可触及的对象不可能被复活，只能被调用一次

    对象不可触及的才可以被回收

#### 对象回收判断

    两次标记过程

    1. 判断引用链，可达对象
    2. 判断会不会执行 finalize() 方法，
       1. 没有重写该方法/已经被虚拟机调用过，判定为不可触及，直接回收
       2. 重写了该方法，并且未执行过，Object 被插入到 F-Queue 队列中，虚拟机创建的，
          低优先级的 Finalizer 线程触发 finalize() 方法执行
       3. finalize() 方法是对象逃脱死亡的最后机会，GC 会对 F-Queue 队列中的对象进行二次标记，如果该对象在 finalize()
          方法中于引用链上任意一个建立了联系，对象被移除即将回收集合，没有建立联系，直接变成不可触及的
          如果该对象再次出现没有引用的情况，就直接变成不可触及的对象，一个对象的 finalize() 方法只能被调用一次

### 清除阶段：标记-清除算法

    区分出来存活对象和死亡对象之后，执行垃圾回收，释放无用空间，为新对象分配内存

    Mark-Sweep

    有效内存空间被耗尽，STW, 进行标记

    标记：从引用根节点开始遍历，标记被引用的对象，在对象的 Header 中进行记录

    回收：如果对象没有被标记，那么就进行回收

    优点：简单
    缺点：效率不高，GC 停止整个应用程序，用户体验较差
          清理出来的空闲空间不连续，产生内存碎片

    清除：不是真的置空，将需要清除的对象地址保存在空闲的地址列表，下次对象分配的时候，如果够，就直接覆盖

### 清除阶段：复制算法

    解决标记-清除算法收集效率缺陷

    活着的内存分为两块，将存活的对象放到另外一块内存中，将所有的可达对象都被复制，那么就将之前的内存全部置空

    优点：没有标记和清除，实现简单，运行高效，保证空间的连续性，没有内存碎片化问题
    缺点：两倍的内存空间，G1 大量的 region, GC 需要维护 region 之间的对象引用关系，内存占用和时间开销都很大

    适用：存活对象很多，复制算法不会很理想

    新生代：朝生夕死，适合使用复制算法

### 清除阶段：标记-压缩算法

    Mark-Compact

    与复制对象相比

    老年代，大多数对象都是存活的，基于老年代使用其它算法，标记清除效率低下，碎片较多

    执行过程：
    1. 标记
    2. 将存活的对象压缩到内存的一段，按顺序排放
    3. 清理边界外的空间

    移动式算法，有引用的需要重新进行引用

    优点：解决了 Mark-Sweep 中内存分散的问题，分配内存之，只需要保存一个内存其实地址，消除了复制算法中内存减半的代价
    缺点：效率低于复制算法和标记-清除算法，需要重新调整地址，需要 STW

### 分代收集算法

    不同生命周期的对象采用不同的搜集方式，提高回收效率

    Http 请求的 Session 对象，线程、Socket 连接，业务挂钩，生命周期比较长，String 对象，周期比较短

    几乎所有的 GC 都是分代搜集

    年轻代：对象周期短，存活率低，回收频繁，适合复制算法
    老年代：区域较大，生命周期长，存活率更高，回收不及年轻代频繁，使用标记-清除或者标记-整理算法
        Mark 阶段与存活对象数量城正比
        Sweep 阶段与所管理的区域大小正相关
        Compact 开销与存活对象的数量成整理
    
    CMS垃圾回收器，标记清除算法，碎片化问题，Serial Old(标记压缩) 回收器作为备胎，用来进行 Full GC 进行老年代回收

### 增量搜集算法、分区算法

    STW 影响用户体验或者系统的稳定性，所以产生增量搜集算法

    垃圾收集线程和应用程序交替执行，每次只收集一小片区域的内存空间，接着切换到引用程序线程，反复直到垃圾收集完成

    标记清除和复制算法，堆线程冲突的妥善处理，垃圾收集线程分阶段的方式完成标记、复制、清理工作

    缺点：线程切换和上下文转换的消耗，垃圾回收的总体成本上升，系统吞吐量下降
    
    分区算法：
    针对 G1 垃圾收集器：将大的分区划分成若干个小的空间，减少一次 GC 产生的停顿

    主流垃圾回收器关注低延迟

    每一个小区间独立使用，独立回收，可以控制一次回收多少个 region, 通过目标的停顿时间进行 region 数量的划分

## 垃圾回收相关概念

### System.gc() 理解

    Runtime.getRuntime().gc()

    显示触发 Full GC 同时回收老年代和新生代

    免责声明，无法保证对垃圾搜集器的调用，不能确保执行时间，只是用来进行性能基准测试

    System.runFinalization() 强制调用失去引用对象的 finalize() 方法

### 内存溢出与内存泄漏

#### 内存溢出

    没有空闲内存，垃圾收集器也无法提供更多内存

    OOM 之前一定会有一次独占式的 Full GC 会回收大量的内存，供程序继续使用
       1. 软引用
       2. System.gc()
       3. 如果分配一个超大的对象，超过堆的最大值，直接 OOM

    没有空闲内存：
       1. 虚拟机堆内存设置不够，可能存在内存泄漏问题
       2. 创建了大对象，长时间不能被垃圾搜集器收集，永久代常量池回收、类回收，可能会回收 OutOfMemoryError
       3. 元空间引入 OOM 的问题有所改观

#### 内存泄漏

    只有对象不会被程序使用，但是 GC 又不能回收，才叫做内存泄漏

    宽泛意义上的内存泄漏：对象的生命周期很长甚至导致 OOM

    不会立即导致内存泄漏，内存被逐渐蚕食，内存最终被耗尽

    此处的内存指的是虚拟内存

    不要举引用计数的例子，因为并没有使用引用计数算法进行垃圾标记

    举例：
       1. 单例模式，Runtime, 如果单例对象又关联了外部的对象的引用，那么这个外部对象是不能被回收的
       2. 一些提供 close 的资源未关闭导致内存泄漏，数据库连接，网络连接，io 连接等 

### STW

    应用程序执行过程中，用户线程因为 GC 暂停，没有任何响应

    可达性分析算法：执行过程中 GC Roots 可能会发生变化，所以必须在一个保证一致性的快照中进行，冻结在某个时间点，
    保证数据结果的准确性

    尽可能减少 STW 的发生

    所有的垃圾回收器都有这个事件

    回收效率越来越高，尽可能缩短暂停时间

    STW 是 JVM 后台自动发起和自动完成，用户正常的工作线程全部停掉

    System.gc() 会导致 STW 发生

### 垃圾回收并行与并发

#### 程序的并行与并发

    Concurrent, 一个时间段中，几个程序处于运行中的状态，任务在同一个处理器上执行
    并不是真正意义上的同时进行， CPU 划片

    并行 Parallel，系统有一个以上的 CPU 时，每一个 CPU 都可以执行一个进程，其实是 CPU 的核心数量

    并发：同一个时间段，互相抢占资源，
    并行：同一个时间点，不互相抢占资源

#### 垃圾回收的并发与并行

    并行：多条垃圾收集线程并行工作
    串行：单线程执行，用户线程和垃圾回收线程串行执行

    并发：一个时间段内，用户线程和垃圾回收线程同时执行，垃圾回收线程执行时不会停顿用户线程运行

### 安全点与安全区域

    安全点：SafePiont
    并非任意时间点都能停下来进行 GC, 特定位置才能进行 GC, 就是所谓的 Safe Point

    安全点太少，GC 等待时间太长，太多，频繁导致运行时的性能问题

    选择标准：执行时间较长的指令作为 Safe Point, 方法调用，循环跳转，异常跳转等等

    GC 发生时候，检查所有线程跑到最近的安全点停顿下来：
    1.  抢占式中断：首先中断所有线程，如果有线程不在安全点，恢复线程，让线程跑到安全点
    2.  主动式中断：设置一个中断标志，线程运行到 Safe Point 主动轮询这个标志，中断标志为真，将自己进行中断挂起

    安全区域：Safe Region
    设置安全区域原因：程序会有不执行的情况，如处于 Sleep 状态或者 Blocked 状态，这个时候无法响应 JVM 中断请求，走到安全点进行中断挂起
    JVM 也不太可能等待线程被唤醒，这种情况，需要 Safe Region 解决

    一段代码片段，对象引用关系不会发生变化，在这个区域中任何位置开始 GC 都是安全的

    实际执行过程：
    1. 当线程运行到 Safe Region 代码时，首先标识已经进入了 Safe Region, 这段时间内发生 GC, JVM 会暂停执行标识为 Safe Region 的用户线程
    2. 线程即将离开 Safe Region 时，检查 JVM 是否完成 GC, 完成则继续运行，否则必须等待直到受到可以安全离开 Safe Region 的信号为止

### 强软弱虚引用

    一类对象，内存空间足够，保留在内存中，内存空间在垃圾回收之后还是很紧张，可以抛弃这些对象

#### 强引用

    赋值引用 Object obj = new Object(), 任何情况下，强引用关系存在，垃圾回收器永远不会回收被引用的对象，不回收

    默认引用类型，强引用的对象都是可触及的

    没有任何引用对象，超过作用域，才会被回收

    相对应的其他三种为：软可触及，弱可触及，虚可触及

    主要的内存泄漏原因

    虚拟机宁愿报 OOM

#### 软引用

    将要内存溢出之前，对象列入回收范围进行第二次回收，内存不足即回收

    是第二次回收，第一次回收指的是不可达对象，如果内存还是不够，就报 OOM

    软引用通常实现内存敏感的数据，告诉缓存使用软引用

    将软引用放在一个引用队列中

    尽量让软引用存活时间长一点

#### 弱引用

    只要垃圾收集工作，都要被回收，发现即回收

    非必须对象，只被弱引用关联的对象，不能维护强引用!!!!!

    不一定很快就能发现持有弱引用的对象

    弱引用瑞祥被回收，被加入到指定的引用队列

    也可以用来保存可有可恶的缓存数据，如安卓手机的三级缓存， 内存 -> 本地 -> 网络

    weakHashMap

#### 虚引用

    不会对生存时间构成影响，唯一目的是该对象被收集器回收时受到一个系统通知

    Phantom Reference 对象回收跟踪

    虚引用完全不会决定对象的生命周期

    get() 方法拿到的都是 null

    唯一目的就是跟踪垃圾回收通知

    创建的时候必须体用一个引用队列作为参数，可以将资源释放操作放在虚引用中执行

    finalization 只能被调用一次

    一旦将 obj 对象回收，发现对象还有虚引用，就会将这个虚引用放到引用队列中

    守护线程，当程序中没有非守护线程时候，守护线程也结束

### 终结器引用

    FinalReference 总结器引用，实现对象的 finalize() 方法，
    
    GC 时候，终结器引用入队，Finalizer 线程通过终结器引用找到被引用的对象，并调用它的 finalize() 方法，第二次 GC 的时候才能回收被引用对象