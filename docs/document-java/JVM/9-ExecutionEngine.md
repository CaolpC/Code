# 执行引擎

## 执行引擎概述

    核心组成部分
    虚拟机 《=》 物理机
    物理机建立在处理器、缓存、指令集和操作系统曾米娜
    虚拟机的执行引擎由软件自行实现，不受物理条件限制，执行不被硬件直接支持的指令集格式

    执行引擎将字节码指令解释、编译为对应的平台上的本地指令才可以
    高级语言翻译成机器语言

## Java 代码编译执行过程

    解释器：对字节码进行逐行解释方式执行，翻译成对应的本地机器指令

    JIT: 虚拟机将源代码直接编译成机器平台相关的语言

    半解释型、半编译型？可以使用解释器、也可以使用即时编译器

## 机器码、指令、汇编语言

    机器指令码，二进制编码，与 CPU 相关

    机器指令：01 构成的二进制序列

    指令集：不同的硬件平台，各自支持的指令

    汇编语言：助记符号替代操作码，汇编语言需要翻译成机器指令码

    字节码：中间状态的二进制码，目的是为了实现跨平台性

## 解释器

    初衷：满足 Java 程序实现跨平台性，所以避免采用静态编译方式直接生成本地机器指令，所以逐行解释

    运行时翻译者

    字节码解释器和模板翻译器，低效！

    即时编译器，整体编译成机器码，函数执行，只执行编译后的机器码  

## JIT 编译器

    解释器，响应速度快

    JVM 启动时，解释器发挥作用，随着程序推移，即时编译器发挥作用，热点探测，执行效率更高

    解释执行再编译器激进优化不成立的时候，作为编译器的逃生门，后备方案

    前端编译器 javac, java 文件翻译成 class 文件

    后端编译器 JIT 编译器，字节码变成机器码

    静态提前编译器 AOT 编译器，.java 文件编译成本地机器码

### 热点代码和探测方式

    代码执行频率，高的是热点代码，进行深度优化

    多次调用的方法，循环次数较多的循环体称为热点代码，发生在方法的执行过程中，也被称为栈上替换

    基于计数器的热点探测，每个方法建立2个不同类型计数器，方法调用计数器和回边计数器（分别对应方法调用和循环体循环次数）

    方法计数器，Client 模式：1500次，Server 模式是10000次， -XX:CompileThreshold 设定

    方法调用时，已经被 JIT 编译，直接执行，没有被执行过，方法 +1 与阈值比较，超过就进行编译，并且对代码进行缓存 Code Cache 放在方法区

    热度衰减：不统计绝对测试，一段时间内方法调用次数，超过一定时间不满足就进行一半衰减，时间称为半衰周期，-XX:-UseCounterDecsy 关闭热度
    衰减，-XX:CounterHalfLifeTime 设置半衰周期时间，单位秒

    回边计数器：循环体执行次数统计

## HotSpot VM 设置程序执行方式

    -Xmixed 混合模式 936ms 默认情况下为混合模式

    -Xint 解释器模式 6520ms

    -Xcomp 纯编译模式 950ms

## JIT 分类

    Client  C1
    Server  C2

    运行在 Client 模式下，使用 C1, 简单可靠的优化，耗时短

    运行在 Server 模式下，使用 C2, 耗时较长的优化，激进优化，代码执行效率更高

    分层编译策略

    Gtaal 编译器，与 C1 C2 并列

    AOT 与 JIT 并列，静态提前编译器，执行之前就翻译成机器码，不必进行即时预热，但是破坏了一次编译、到处运行的特性，降低了 Java 链接过程的
    动态性，只支持 Linux x64