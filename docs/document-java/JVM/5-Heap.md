# 堆

    JVM 实例只有一个堆内存，核心

    启动的时候 JVM 创建，堆空间确定，最大一块内存空间

    堆大小可以调节

    物理不连续，逻辑上连续

    所有线程共享，还可以划分线程私有缓冲区（TLAB）

***几乎所有对象实例和数组运行时都应该分配在堆上***

    逃逸分析、栈上分配

    数组和对象可能永远不会存储在栈上，栈帧中保存引用，引用指向对象或者数组在堆中的位置

    方法结束，对象不是马上被清除，在进行垃圾回收的时候才会被回收

    堆是垃圾回收的重点区域

## 内存细分

    分代收集理论

    Java7: 新生代 + 老年代 + 永久代

    Java8: 新生代 + 老年代 + 元空间

    新生代：Eden + S0 + S1

***永久代和元空间是方法区的落地实现！***

### 堆空间大小设置

    新生代 + 老年代

    -Xms 堆区初始内存 <====> -XX:InitialHeapSize  memory start

    -Xmx 堆区最大内存 <====> -XX:MaxHeapSize  memory max

    默认堆空间大小：最小：操作系统/64： 最大: 操作系统/16

    开发中建议将初始堆内存和最大堆内存设置为一样的，防止内存抖动

***计算内存值只考虑一个幸存者区域！所以内存会变小***

    jps / jstat -gc 进程id

    -XX:+PrintGCDetatil

### OutOfMemory

    广义的异常(Throwable)： Error + Exception

### 新生代和老年代相关参数设置

    生命周期：瞬时对象，创建和消亡都和迅速；生命周期很长，可能与 JVM 生命周期一样

    新生代 和 老年代

    新生代：Eden + Survivor0 + Survivor1

    默认参数： 
        -XX:NewRatio = 2 新生代占1，老年代占2
        -XX:SurvivorRatio = 8 伊甸园区占8，两个 Survivor 分别占1

***但是在程序中展示结果不一致，因为存在自适应机制***

    -XX:-UseAdaptiveSizePolicy 关闭自适应内存分配策略，这个参数不好使

    需要显示指定  -XX:SurvivorRatio = 8

    几乎所有的对象都在 Eden 区创建

    绝大多数对象都在新生代被销毁了

    -Xmn 设置新生代最大内存大小，显示指定则比例失效

### 对象分配过程

    首先将对象放在 Eden 区

    一旦 Eden 区满，进行垃圾回收 YGC/Minor GC, STW, 引用计数算法、可达性分析算法

    把没有被回收的放在 S0/S1 区，放在两个区为空的空间，原有的对象（没有被回收的）年龄 +1， 

    S0/S1 进行晋升，阈值判断，默认是15 -XX:MaxTenuringThreshold=<N>

***YGC 只有在 Eden 区满的时候才会触发，S0/S1 区满了不会触发 YGC, S0/S1 被动回收***

    S0/S1 满了可能直接晋升到老年代， Eden 区满了也可能直接晋升到老年代

***复制之后有交换，谁空谁是 to***
***频繁收集新生代，较少回收老年代，几乎不动永久代/元空间***

### 对象分配的特殊情况

    新生代放不下，YGC 之后也放不下，那直接放到老年代

    老年代也放不下，Full GC 之后也放不下，OOM

    YGC 之后，Eden 区对象放到 S0/S1 放不下（回收之后），直接晋升到老年代，超过阈值也会晋升到老年代

### Minor GC、Major GC、Full GC

    Minor GC == YGC，年轻代满

#### Major GC 和 Full GC 的区别

    HotSpot JVM

    部分搜集 Partial GC

        minor GC / YGC 新生代
        Major / Old GC 老年代，只有 CMS 单独搜集老年代，很多时候 Major GC 和 Full GC 混淆使用
        混合回收，收集新生代以及部分老年代垃圾搜集， G1 GC 会有，G1 Region 区域划分，可能是新生代也可能是老年代

    整堆搜集 Full GC: 搜集整个 Java 堆和方法区

    YGC 触发时机：
        年轻代空间不足，Eden 区满！S0/S1 不会触发！，朝生夕死，STW 时间较短

    老年代触发机制：
        Major GC， 至少一次 YGC, Paraller Scavenge 有直接 Major GC 的策略选择
        比 YGC 慢 10 倍
        空间不足 OOM 
    
    Full GC 触发：
        System.gc()
        老年代空间不足
        方法区不足
        S0/S1 满了可能直接晋升到老年代， Eden 区满了也可能直接晋升到老年代，这两种也可能导致 Full GC

    OOM 之前一定会有一次 Full GC

#### 空间分代

    不同对象生命周期不同，大多数对象都是朝生夕死的

    优化 GC 性能

#### 内存分配策略

    一般情况，上述对象分配过程

    对象提升规则：
        优先分配到 Eden
        大对象分配到老年代，连续的对象，Eden 放不下，避免出现过多大对象
        长期存活的对象分配到老年代(年龄计数器)
        动态对象年龄判断，S 区中相同年龄的所有对象综合大于 S 空间的一般，年龄大于或者等于的直接进入老年代
        空间分配担保：S 区无法放下的直接放到老年代，必须满足老年代的空间足够

#### TLAB

    Thread Local Allocation Buffer

    堆区，共享数据，并发多线程不安全

    加锁机制，影响分配速度

    对 Eden 进行划分，每个线程分配一个独立的私有缓存区域， TLAB

    TLAB 空间较小， 但是 JVM 将 TLAB 作为内存分配的首选

    -XX:UseTLAB 默认开启

    默认占 Eden 1% 的空间

    一旦对象在 TLAB 内存分配失败，尝试使用加所机制保持线程的安全性

    堆空间一定是共享的吗，不是！有线程私有的 TLAB

### 堆空间参数设置小结

    新生代最大年龄，是放在对象头中的，最大为 15

    是否设置空间分配担保：

        Minor GC 之前，虚拟机检查老年代最大可用的连续空间是否大于新生代所有对象的总空间
            大于：此次 Minor GC 安全
            小于：查看 -XX: HandlePromotionFailure 设置是否允许担保失败
                true: 允许担保失败：检查老年代最大可用空间是否大于历次晋升到老年代的对象平均大小
                    大于：进行 Minor GC，但是仍然存在风险
                    小于: 进行 Full GC
                false: 进行 Full GC
        
        JDK6(24) 之后，该参数不影响空间分配担保策略，规则变为：
***老年代最大可用的连续空间大于新生代所有对象的总空间，或者大于历次晋升到老年代的对象平均大小，进行 Minor GC， 否则进行 Full GC***

### 堆空间是分配对象存储的唯一选择吗

    不是！

    JIT 发展，逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术导致分配到堆不那么绝对

    一个对象如果没有逃逸出方法的话，就可能被优化成栈上分配，常见的堆外存储技术

    TaoBaoVM GCIH 实现 off-heap, 生命周期较长的对象从堆内移动到堆外

    对象方法内定义，只在方法内部定义，认为没有发生逃逸，就可以在栈上分配，方法结束，栈空间被移除

    如何快速判断是否发生逃逸分析：看 new 的对象实体是否有可能在方法外被调用

    与对象是否被 static 修饰无关

    引用成员变量的值，发生逃逸

    开发中能使用局部变量的，就不要在方法外定义

#### 栈上分配

    没有发生逃逸，进行栈上分配，线程结束，栈帧出栈，栈空间回收，局部变量回收

#### 同步省略

    一个对象被发现只能从一个线程被访问当，那么对于这个对象的操作可以不考虑同步

    JIT 借助逃逸分析判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其它线程

    JIT 在编译这个同步块的时候会取消这部分代码的同步

    同步省略，锁消除

#### 分离对象或标量替换

    对象不需要作为一个连续内存结构也可以被访问

    对象的全部可以不存放在内存中，存储在 CPU 寄存器中就可以

    标量，无法再分解，原始数据类型

    聚合量：还可以再分解成标量的数据

    逃逸分析，对象拆解为标量

#### 代码优化及堆小结

    逃逸分析暂时不成熟，需要进行一系列复杂的分析，相对耗时

    所有的对象实例都是创建在堆上
